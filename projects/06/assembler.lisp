#!/usr/bin/env sbcl --script

(require 'uiop)

;; Utility functions

(defun last-val (l)
  (first (last l)))

(defun dec->bin (n)
  (multiple-value-bind (r m) (floor n 2)
    (if (= n 0) nil (cons m (dec->bin r)))))

(defun dec-to-bin (n)
  (reverse (dec->bin (parse-integer n))))

(defun list-to-string (lst)
  (if (not (listp lst)) lst
      (format nil "~{~A~}" lst)))

(defun lpad (target char lst)
  (if (< (length lst) target)
      (lpad target char (concatenate 'string char lst))
      lst))

;; Class definitions

(defclass parser ()
  ((filename :initarg :filename)
   (filestream :accessor filestream)
   (current-line :initform nil :accessor current-line)))
(defmethod initialize-instance :after ((obj parser) &key)
  (let ((filename (slot-value obj 'filename)))
    (setf (filestream obj)
	  (open filename))))
(defmethod advance ((obj parser))
  (if (has-more-commands? obj)
      (let ((line (string-trim " " (first (uiop:split-string (read-line (filestream obj)) :separator "//")))))
	(if (is-invalid-line? obj line)
	    (advance obj)
	    (setf (current-line obj) line)))
      (setf (current-line obj) nil)))
(defmethod is-invalid-line? ((obj parser) line)
  (or (null line)
      (eq 0 (length line))
      (and (> (length line) 1)
	   (string= "//" (subseq line 0 2)))))
(defmethod has-more-commands? ((obj parser))
  (not (null (peek-char t (filestream obj) nil))))
(defmethod command-type ((obj parser))
  (let* ((line (current-line obj))
	 (first-char (char line 0)))
    (cond ((eq #\@ first-char) "A_COMMAND")
	  ((eq #\( first-char) "L_COMMAND")
	  (t "C_COMMAND"))))
(defmethod a-command? ((obj parser)) (string= (command-type obj) "A_COMMAND"))
(defmethod l-command? ((obj parser)) (string= (command-type obj) "L_COMMAND"))
(defmethod c-command? ((obj parser)) (string= (command-type obj) "C_COMMAND"))
(defmethod the-symbol ((obj parser))
  (let* ((type (command-type obj))
	 (line (current-line obj)))
    (cond ((a-command? obj) (subseq line 1))
	  ((l-command? obj) (string-trim "()" line)))))
(defmethod dest ((obj parser))
  (let ((line (current-line obj)))
    (if (c-command? obj)
	(if (not (null (find #\= line)))
	    (first (uiop:split-string line :separator "="))))))
(defmethod comp ((obj parser))
  (if (c-command? obj)
      (let* ((line (current-line obj))
	     (right-side (last-val (uiop:split-string line :separator "=")))
	     (split-on-semicolon (uiop:split-string right-side :separator ";"))
	     (val (first split-on-semicolon)))
	(if (> (length val) 0) val))))
(defmethod jump ((obj parser))
  (if (c-command? obj)
      (last-val (uiop:split-string (current-line obj) :separator ";"))))


(defclass code ()
  ((val :initarg :val)))
(defmethod code-dest ((obj code) mnemonic)
  (let ((sorted-mnemonic (sort mnemonic #'char-lessp)))
    (cond ((null sorted-mnemonic) "000")
	  ((string= "M" sorted-mnemonic) "001")
	  ((string= "D" sorted-mnemonic) "010")
	  ((string= "DM" sorted-mnemonic) "011")
	  ((string= "A" sorted-mnemonic) "100")
	  ((string= "AM" sorted-mnemonic) "101")
	  ((string= "AD" sorted-mnemonic) "110")
	  ((string= "ADM" sorted-mnemonic) "111"))))
(defmethod code-comp ((obj code) mnemonic)
  (cond ((string= "0" mnemonic)   "0101010")
	((string= "1" mnemonic)   "0111111")
	((string= "-1" mnemonic)  "0111010")
	((string= "D" mnemonic)   "0001100")
	((string= "A" mnemonic)   "0110000")
	((string= "M" mnemonic)   "1110000")
	((string= "!D" mnemonic)  "0001101")
	((string= "!A" mnemonic)  "0110001")
	((string= "!M" mnemonic)  "1110001")
	((string= "-D" mnemonic)  "0001111")
	((string= "-A" mnemonic)  "0110011")
	((string= "-M" mnemonic)  "1110011")
	((string= "D+1" mnemonic) "0011111")
	((string= "1+D" mnemonic) "0011111") ; reversed
	((string= "A+1" mnemonic) "0110111")
	((string= "1+A" mnemonic) "0110111") ; reversed
	((string= "M+1" mnemonic) "1110111")
	((string= "1+M" mnemonic) "1110111") ; reversed
	((string= "D-1" mnemonic) "0001110")
	((string= "A-1" mnemonic) "0110010")
	((string= "M-1" mnemonic) "1110010")
	((string= "D+A" mnemonic) "0000010")
	((string= "A+D" mnemonic) "0000010") ; reversed
	((string= "D+M" mnemonic) "1000010")
	((string= "M+D" mnemonic) "1000010") ; reversed
	((string= "D-A" mnemonic) "0010011")
	((string= "D-M" mnemonic) "1010011")
	((string= "A-D" mnemonic) "0000111")
	((string= "M-D" mnemonic) "1000111")
	((string= "D&A" mnemonic) "0000000")
	((string= "A&D" mnemonic) "0000000") ; reversed
	((string= "D&M" mnemonic) "1000000")
	((string= "M&D" mnemonic) "1000000") ; reversed
	((string= "D|A" mnemonic) "0010101")
	((string= "A|D" mnemonic) "0010101") ; reversed
	((string= "D|M" mnemonic) "1010101")
	((string= "M|D" mnemonic) "1010101") ; reversed
	))
(defmethod code-jump ((obj code) mnemonic)
  (cond ((null mnemonic) "000")
	((string= "JGT" mnemonic) "001")
	((string= "JEQ" mnemonic) "010")
	((string= "JGE" mnemonic) "011")
	((string= "JLT" mnemonic) "100")
	((string= "JNE" mnemonic) "101")
	((string= "JLE" mnemonic) "110")
	((string= "JMP" mnemonic) "111")))

(defun construct-output-filename (in)
  (concatenate 'string (subseq in 0 (- (length in) 4)) ".hack"))

(defun main (argv)
  (let* ((*input-filename* (uiop:native-namestring argv))
  	 (*parser* (make-instance 'parser :filename *input-filename*))
  	 (*output-filename* (construct-output-filename *input-filename*))
  	 (*code* (make-instance 'code :val 1)))
    ;; (setf (current-line *parser*) "D=A")
    ;; (write-line (concatenate 'string
    ;; 			     "111"
    ;; 			     (code-comp *code* (comp *parser*))
    ;; 			     (code-dest *code* (dest *parser*))
    ;; 			     (code-jump *code* (jump *parser*))))))
    (with-open-file (stream *output-filename* :direction :output :if-exists :supersede)
      (loop while (has-more-commands? *parser*)
	   do
	   (advance *parser*)
	   (let ((line (cond ((c-command? *parser*)
			      (concatenate 'string
					   "111"
					   (code-comp *code* (comp *parser*))
					   (code-dest *code* (dest *parser*))
					   (code-jump *code* (jump *parser*))))
			     ((a-command? *parser*)
			      (dec-to-bin (the-symbol *parser*))))))
  		;; (if (and (c-command? *parser*) (null (jump *parser*)))
  		;;     (write-line (code-jump *code* (jump *parser*))))
  		    ;(write-line (concatenate 'string (current-line *parser*) "-->" (command-type *parser*))))
  		;(write-line (or (code-dest *code* (dest *parser*)) (concatenate 'string "NULLLLL: " (dest *parser*))))
  		;(write-line (list-to-string (list (list-to-string line) "===>" (lpad 16 "0" (list-to-string line)))))
					;(write-line (concatenate 'string (lpad 16 "0" (list-to-string line)) "-->" (current-line *parser*)))))
	     ( "LINE: ")
	     (print (current-line *parser*))
	     (print "-->")
	     (print "VAL: ")
	     (print (list (code-comp *code* (comp *parser*)) (c-command? *parser*)))
	     (print "END")
	     ;(format t (lpad 16 "0" (list-to-string line)))))))
	     ;(write-line (concatenate 'string (current-line *parser*) "-->" (lpad 16 "0" (list-to-string line)))))))
		)))))
  		;(iter)))))
      ;(iter))))

(main (second *posix-argv*))
